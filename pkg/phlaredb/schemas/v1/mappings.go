package v1

import "github.com/segmentio/parquet-go"

var mappingsSchema = parquet.SchemaOf(new(InMemoryMapping))

type MappingPersister struct{}

func (*MappingPersister) Name() string { return "mappings" }

func (*MappingPersister) Schema() *parquet.Schema { return mappingsSchema }

func (*MappingPersister) SortingColumns() parquet.SortingOption { return parquet.SortingColumns() }

func (*MappingPersister) Deconstruct(row parquet.Row, _ uint64, m *InMemoryMapping) parquet.Row {
	row = mappingsSchema.Deconstruct(row, m)
	return row
}

func (*MappingPersister) Reconstruct(row parquet.Row) (uint64, *InMemoryMapping, error) {
	var mapping InMemoryMapping
	if err := mappingsSchema.Reconstruct(&mapping, row); err != nil {
		return 0, nil, err
	}
	return 0, &mapping, nil
}

type InMemoryMapping struct {
	// Unique nonzero id for the mapping.
	Id uint64
	// Address at which the binary (or DLL) is loaded into memory.
	MemoryStart uint64
	// The limit of the address range occupied by this mapping.
	MemoryLimit uint64
	// Offset in the binary that corresponds to the first mapped address.
	FileOffset uint64
	// The object this entry is loaded from.  This can be a filename on
	// disk for the main binary and shared libraries, or virtual
	// abstractions like "[vdso]".
	Filename uint32
	// A string that uniquely identifies a particular program version
	// with high probability. E.g., for binaries generated by GNU tools,
	// it could be the contents of the .note.gnu.build-id field.
	BuildId uint32
	// The following fields indicate the resolution of symbolic info.
	HasFunctions    bool
	HasFilenames    bool
	HasLineNumbers  bool
	HasInlineFrames bool
}
